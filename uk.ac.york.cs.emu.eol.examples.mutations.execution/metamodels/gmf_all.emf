@namespace(uri="http://www.eclipse.org/gmf/2005-2008/gmf_all", prefix="gmf_all")
package gmf_all;

@EmfaticAnnotationMap(constraints="http://www.eclipse.org/gmf/2005/constraints", constraintsMeta="http://www.eclipse.org/gmf/2005/constraints/meta")
@constraints("import"="http://www.eclipse.org/gmf/runtime/1.0.0/notation")
@namespace(uri="http://www.eclipse.org/gmf/2008/mappings", prefix="gmfmap")
package mappings {
  @constraints(ocl="nodes->forAll(n|n.containmentFeature.oclIsUndefined() and not n.child.domainMetaElement.oclIsUndefined() implies links->exists(let r:ecore::EReference= linkMetaFeature.oclAsType(ecore::EReference) in r.containment and r.eReferenceType.isSuperTypeOf(n.child.domainMetaElement)))", description="Phantom nodes that are not targeted by a link mapping representing containment reference present in the model")
  class Mapping {
    !resolve val TopNodeReference[*] nodes;
    !resolve val LinkMapping[*] links;
    !resolve val CanvasMapping[1] diagram;
    val tooldef.StyleSelector[*] appearanceStyles;
    val AuditContainer audits;
    val MetricContainer metrics;
  }

  abstract class MappingEntry {

    @GenModel(documentation="This method simplifies OCL expressions (makes it easy to write for both Node and Link).")
    op EClass getDomainContext();
    ref EClass domainMetaElement;

    @GenModel(documentation="Specializes further the domain meta element EClass associated with this mapping and should be evaluated in this EClass context")
    @constraintsMeta(def="context", ocl="self.getDomainContext()")
    @constraints(ocl="not domainSpecialization.oclIsUndefined() implies not domainMetaElement.oclIsUndefined()", description="Using 'Domain Specialization' requires 'Domain Meta Element' to be set")
    val Constraint domainSpecialization;

    @GenModel(documentation="Initializer for the domain model element associated with mapping")
    @constraints(ocl="not domainInitializer.oclIsUndefined() implies not domainMetaElement.oclIsUndefined()", description="'Domain Element' must be set in mapping with 'Element Initializers'")
    val ElementInitializer domainInitializer;
    val LabelMapping[*]#mapEntry labelMappings;

    @GenModel(documentation="Diagrams that may be associated with this diagram element. It's up to client application to define what this association means (e.g. open diagram)")
    ref CanvasMapping[*] relatedDiagrams;
    val VisualEffectMapping[*]#parentMapEntry visualEffects;
  }

  abstract interface NeedsContainment {

    @constraints(ocl="not containmentFeature.oclIsUndefined() implies containmentFeature.containment", description="Containment EReference expected")
    ref ecore.EReference containmentFeature;
  }

  @constraints(ocl="not containmentFeature.oclIsUndefined() implies containmentFeature.eReferenceType.isSuperTypeOf(child.domainMetaElement)", description="'Containment Feature' must reference the same class or super type of 'Domain Meta Element' of the referenced node")
  abstract class NodeReference extends NeedsContainment {

    @constraints(ocl="not childrenFeature.oclIsUndefined() implies childrenFeature.eReferenceType.isSuperTypeOf(child.domainMetaElement)", description="'Children Feature' must reference the same class or super type of 'Domain Meta Element' of the referenced node")
    ref ecore.EReference childrenFeature;
    readonly volatile transient unsettable derived !resolve ref NodeMapping child;
  }

  @constraints(ocl="not (ownedChild.oclIsUndefined() and referencedChild.oclIsUndefined())", description="Either 'ownedChild' or 'referencedChild' NodeMapping must be set")
  @constraints(ocl="not childrenFeature.oclIsUndefined() implies childrenFeature.eContainingClass.isSuperTypeOf(parentNode.domainMetaElement)", description="'Children Feature' must be owned by 'Domain Meta Element' or its super type of this reference parent Node Mapping")
  @constraints(ocl="not containmentFeature.oclIsUndefined() implies containmentFeature.eContainingClass.isSuperTypeOf(parentNode.domainMetaElement)", description="'Containment Feature' must be owned by 'Domain Meta Element' or its super type of this reference parent Node Mapping")
  @constraints(ocl="not child.getDomainContext().oclIsUndefined() implies not containmentFeature.oclIsUndefined()", description="ChildReference to NodeMapping with domainElement should define 'containmentFeature'")
  @constraints(ocl="let child:NodeMapping=(if ownedChild.oclIsUndefined() then referencedChild else ownedChild endif) in (((child.labelMappings->size() = 1) and child.labelMappings->forAll( soleLabel: LabelMapping | soleLabel.diagramLabel = child.diagramNode)) implies (child.diagramNode.affixedParentSide = gmfgraph::Direction::NONE))", description="Side-affixed children can not be pure labels")
  @constraints(ocl="let child:NodeMapping=(if ownedChild.oclIsUndefined() then referencedChild else ownedChild endif) in ((not compartment.oclIsUndefined()) implies (child.diagramNode.affixedParentSide = gmfgraph::Direction::NONE))", description="Side-affixed children can not be placed in compartments")
  class ChildReference extends NodeReference {
    ref NodeMapping[1]#children parentNode;
    ref CompartmentMapping#children compartment;
    val NodeMapping ownedChild;
    ref NodeMapping referencedChild;
  }

  class TopNodeReference extends NodeReference {
    val NodeMapping[1] ownedChild;
  }

  @GenModel(documentation="Both top-level diagram node and any inner node")
  class NodeMapping extends MappingEntry, MenuOwner, ToolOwner, AppearanceSteward {
    ref gmfgraph.Node[1] diagramNode;
    val ChildReference[*]#parentNode children;
    val CompartmentMapping[*]#parentNode compartments;
  }

  class CompartmentMapping {
    ref gmfgraph.Compartment[1] compartment;
    readonly !resolve ref NodeMapping[1]#compartments parentNode;
    ref ChildReference[*]#compartment children;
  }

  @GenModel(documentation="Connection element")
  @constraints(ocl="domainMetaElement.oclIsUndefined() implies containmentFeature.oclIsUndefined() and sourceMetaFeature.oclIsUndefined()", description="Link mapping without 'Domain Element' class does not use 'Containment Feature' and 'Source Feature'")
  @constraints(ocl="not domainMetaElement.oclIsUndefined()  implies containmentFeature.eReferenceType.isSuperTypeOf(domainMetaElement)", description="'Containment Feature' must reference the same class or super type of 'Domain Element' EClass")
  class LinkMapping extends MappingEntry, NeedsContainment, MenuOwner, ToolOwner, AppearanceSteward {
    ref gmfgraph.Connection[1] diagramLink;

    @constraints(ocl="not domainMetaElement.oclIsUndefined() implies sourceMetaFeature.oclIsUndefined() or sourceMetaFeature.eContainingClass.isSuperTypeOf(domainMetaElement)", description="'Source Feature' must be owned by the link 'Domain Element' or its super type")
    ref ecore.EStructuralFeature sourceMetaFeature;

    @constraints(ocl="not(domainMetaElement.oclIsUndefined() or linkMetaFeature.oclIsUndefined()) implies linkMetaFeature.eContainingClass.isSuperTypeOf(domainMetaElement)", description="'Target Feature' must be owned by the link 'Domain Element' or its super type")
    ref ecore.EStructuralFeature linkMetaFeature;

    @GenModel(documentation="Specifies additional restrictions on link creation")
    val LinkConstraints#linkMapping creationConstraints;
  }

  class CanvasMapping {
    ref gmfgraph.Canvas[1] diagramCanvas;
    ref ecore.EPackage domainModel;

    @constraints(ocl="not domainMetaElement.oclIsUndefined() implies not(domainMetaElement.abstract or domainMetaElement.interface)", description="Top-level diagram container must be concrete")
    ref EClass domainMetaElement;
    ref tooldef.Palette palette;
    ref tooldef.MainMenu[*] menuContributions;
    ref tooldef.Toolbar[*] toolbarContributions;
  }

  @GenModel(documentation="Label definition; text is taken from the graph model; no editing support; user may contribute custom parser")
  class LabelMapping {
    ref gmfgraph.DiagramLabel[1] diagramLabel;
    attr boolean readOnly;
    readonly !resolve ref MappingEntry[1]#labelMappings mapEntry;
  }

  @GenModel(documentation="Label based on feature(s) from domain model")
  class FeatureLabelMapping extends LabelMapping {

    @constraints(ocl="features->forAll(f | f.eContainingClass.isSuperTypeOf(mapEntry.domainMetaElement))", description="Label attributes must be available in 'Domain Element' EClass of the labeled mapping entry")
    ref ecore.EAttribute[+] features;

    @constraints(ocl="editableFeatures->forAll(f | f.eContainingClass.isSuperTypeOf(mapEntry.domainMetaElement))", description="Label attributes must be available in 'Domain Element' EClass of the labeled mapping entry")
    ref ecore.EAttribute[*] editableFeatures;

    @GenModel(documentation="Pattern to produce label on diagram, depends on view method")
    attr String viewPattern;

    @GenModel(documentation="Pattern to produce text for inplace editor, depends on view method; if not specified then viewPattern should be used")
    attr String editorPattern;

    @GenModel(documentation="Pattern to extract values from input text, depends on edit method; if not specified then viewPattern should be used")
    attr String editPattern;
    attr LabelTextAccessMethod viewMethod;
    attr LabelTextAccessMethod editMethod;
  }

  @GenModel(documentation="Label based on a feature (reference or attribute) from domain model and list of choices")
  class OclChoiceLabelMapping extends LabelMapping {

    @constraints(ocl="feature.eContainingClass.isSuperTypeOf(mapEntry.domainMetaElement)", description="Label reference must be available in 'Domain Element' EClass of the labeled mapping entry")
    @constraints(ocl="feature.oclIsKindOf(ecore::EReference) implies (not(feature.oclAsType(ecore::EReference).containment) and (feature.oclAsType(ecore::EReference).upperBound = 1))", description="Reference feature should not be containment and don't be multiple")
    @constraints(ocl="feature.oclIsKindOf(ecore::EAttribute) implies (itemsExpression <> null)", description="Items expression should be set if feature is an EAttribute")
    ref ecore.EStructuralFeature[1] feature;
    val ValueExpression itemsExpression;
    val ValueExpression showExpression;
  }

  enum LabelTextAccessMethod {
    MESSAGE_FORMAT = 0;
    NATIVE = 1;
    REGEXP = 2;
    PRINTF = 3;
  }

  @GenModel(documentation="Label based on DescriptionStyle from notation model")
  class DesignLabelMapping extends LabelMapping {
  }

  @GenModel(documentation="Label based on a calculated value")
  class ExpressionLabelMapping extends LabelMapping {

    @GenModel(documentation="Expression to produce regular label value. Evaluated in the context of the owning mapEntry.domainMetaElement")
    val ValueExpression[1] viewExpression;

    @GenModel(documentation="Optional expression to produce editable string representation of the label. If not set, viewExpression is used.")
    val ValueExpression editExpression;

    @GenModel(documentation="Boolean expression in a string context, which able to tell whether user-entered text is valid.")
    val Constraint validateExpression;
  }

  @GenModel(documentation="Boolean type value expression which is to be evaluated in a context")
  @constraintsMeta(def="Constraint")
  class Constraint extends ValueExpression {
  }

  @GenModel(documentation="Groups constraints on the link source and target end")
  @constraints(ocl="not (sourceEnd.oclIsUndefined() and targetEnd.oclIsUndefined())", description="Either 'sourceEnd' or 'targetEnd' constraint must be specified")
  class LinkConstraints {

    @GenModel(documentation="References the link mapping restricted by these constraints")
    readonly !resolve ref LinkMapping[1]#creationConstraints linkMapping;

    @GenModel(documentation="Restriction enforced by the the source end, may reference variable 'oppositeEnd' pointing to targetEnd domainMetaElement instance if available.")
    @constraintsMeta(def="context", ocl="let lm:LinkMapping=linkMapping in if lm.sourceMetaFeature.oclIsUndefined() then (if lm.containmentFeature.oclIsUndefined() then lm.linkMetaFeature.eContainingClass else lm.containmentFeature.eContainingClass endif) else lm.sourceMetaFeature.oclAsType(ecore::EReference).eReferenceType endif")
    @constraintsMeta(def="variable", name="oppositeEnd", type.ocl="linkMapping.linkMetaFeature.eType")
    val Constraint sourceEnd;

    @GenModel(documentation="Restriction enforced by the the target end, may reference variable 'oppositeEnd' pointing to sourceEnd domainMetaElement instance.")
    @constraintsMeta(def="context", ocl="linkMapping.linkMetaFeature.eType.oclAsType(ecore::EClass)")
    @constraintsMeta(def="variable", name="oppositeEnd", type.ocl="let lm:LinkMapping=linkMapping in if lm.sourceMetaFeature.oclIsUndefined() then (if lm.containmentFeature.oclIsUndefined() then lm.linkMetaFeature.eContainingClass else lm.containmentFeature.eContainingClass endif) else lm.sourceMetaFeature.oclAsType(ecore::EReference).eReferenceType endif")
    val Constraint targetEnd;
  }

  @constraintsMeta(def="ValueSpec")
  @GenModel(documentation="Expression as a textual statement which results in a value when evaluated in a context")
  class ValueExpression {

    @GenModel(documentation="The text of the expression")
    @constraintsMeta(def="body")
    attr String[1] body;

    @GenModel(documentation="Specifies the language in which the expression is stated")
    attr Language[1] language = "ocl";

    @constraintsMeta(def="lang")
    readonly volatile transient derived attr String langName;
  }

  @GenModel(documentation="Base class for initializers of domain model elements")
  abstract interface ElementInitializer {

    @GenModel(documentation="The 'MappingEntry' whose domain model element is to be intialized by this initializer")
    readonly volatile transient ref MappingEntry[1] mappingEntry;
  }

  @GenModel(documentation="Feature sequence initializer to initialize a sequence of features")
  class FeatureSeqInitializer extends ElementInitializer {

    @GenModel(documentation="Value specifications as initializers for individual features which should be initialized in the order given by this list")
    val FeatureInitializer[+]#featureSeqInitializer initializers;

    @constraints(ocl="not creatingInitializer.feature.oclIsUndefined() implies creatingInitializer.feature.oclAsType(ecore::EReference).eReferenceType.isSuperTypeOf(elementClass)", description="'elementClass' must be the same as or sub-type of the containing 'GenReferenceNewElementSpec' reference type")
    @constraints(ocl="not creatingInitializer.feature.oclIsUndefined() implies not (elementClass.interface or elementClass.abstract)", description="'elementClass' must be a concrete EClass which is the same or sub-type of the containing 'GenReferenceNewElementSpec' reference type")
    ref EClass elementClass;
    readonly !resolve ref ReferenceNewElementSpec#newElementInitializers creatingInitializer;
  }

  abstract class FeatureInitializer {

    @GenModel(documentation="The feature for which is to be initialized by this initializer")
    @constraints(ocl="feature <> null implies not featureSeqInitializer.initializers->exists(i| i <> self and i.feature = self.feature)", description="The feature is already initialized by another 'FeatureInitializer' in the sequence")
    @constraints(ocl="feature <> null implies feature.eContainingClass.isSuperTypeOf(featureSeqInitializer.elementClass)", description="The 'feature' of 'FeatureInitializer' must be available in 'Meta Class' of the initialized element")
    @constraints(ocl="feature <> null implies feature.changeable", description="The 'feature' of 'FeatureInitializer' must be changeable")
    ref ecore.EStructuralFeature[1] feature;
    readonly !resolve ref FeatureSeqInitializer[1]#initializers featureSeqInitializer;
  }

  @GenModel(documentation="Value specification associated with a specific feature")
  class FeatureValueSpec extends FeatureInitializer {

    @constraintsMeta(def="context", ocl="featureSeqInitializer.elementClass")
    @constraintsMeta(def="type", ocl="feature")
    val ValueExpression[1] value;
  }

  @constraints(ocl="feature.many = false implies not (newElementInitializers->size() > 1)", description="FeatureInitializer for single element EReference can't contain multiple element initializers")
  @constraints(ocl="let r: ecore::EReference = feature.oclAsType(ecore::EReference) in feature <> null implies r.containment", description="'feature' of 'ReferenceNewElementSpec' must refer to containment ecore::EReference")
  class ReferenceNewElementSpec extends FeatureInitializer {
    val FeatureSeqInitializer[+]#creatingInitializer newElementInitializers;
  }

  abstract interface MenuOwner {
    ref tooldef.ContextMenu contextMenu;
  }

  abstract interface ToolOwner {

    @GenModel(documentation="Way to create this element")
    ref tooldef.AbstractTool tool;
  }

  abstract interface AppearanceSteward {
    ref tooldef.StyleSelector appearanceStyle;
  }

  @GenModel(documentation="Container for audit rules representing a hierarchical organization of audits in the constraint category hierarchy of emft.validation framework")
  class AuditContainer {

    @GenModel(documentation="Identifier which is unique within the scope of its parent container.")
    @constraints(ocl="not parentContainer.oclIsUndefined() implies parentContainer.childContainers->one(i | i.id = self.id)", description="Audit container with the same ID already exists")
    attr String[1] ~id;

    @GenModel(documentation="A human readable name for the category of audits organized in this container")
    attr String name;

    @GenModel(documentation="The detailed description of this audit container")
    attr String description;
    ref AuditContainer#childContainers parentContainer;

    @GenModel(documentation="The audit rules organized in this container")
    val AuditRule[*]#container audits;
    val AuditContainer[*]#parentContainer childContainers;
  }

  @GenModel(documentation="Base class for rule like audit, metric rules...")
  abstract interface RuleBase {

    @GenModel(documentation="A human readable name of this rule")
    attr String name;

    @GenModel(documentation="The detailed description of this rule semantics")
    attr String description;
  }

  class AuditRule extends RuleBase {

    @GenModel(documentation="Unique identifier of this audit rule")
    @constraints(ocl="not id.oclIsUndefined() implies container.audits->one(i | i.id = self.id)", description="Audit rule with the same ID already exists")
    attr String[1] ~id;

    @GenModel(documentation="A boolean type condition which if not satisfied indicates this audit rule violation. It is evaluated in the context of the target")
    @constraintsMeta(def="context", "ref"="target")
    val Constraint[1] rule;

    @GenModel(documentation="The target representing the context this audit is evaluated in")
    val Auditable[1] target;

    @GenModel(documentation="Describes the severity of this audit rule violation")
    attr Severity severity = "ERROR";

    @GenModel(documentation="Indicates if this audit should be evaluated also in Live mode. If 'false', only Batch mode is applicable")
    attr boolean useInLiveMode = false;

    @GenModel(documentation="The text message to be reported in case of this audit violation")
    attr String message;

    @GenModel(documentation="The containing audit container of this audit rule")
    ref AuditContainer[1]#audits container;
  }

  @GenModel(documentation="Target for rules applied on domain model elements")
  @constraintsMeta(def="context", ocl="element")
  class DomainElementTarget extends Auditable, Measurable {

    @GenModel(documentation="Targeted domain model element")
    ref EClass[1] element;
  }

  @GenModel(documentation="Represents value based target, useful for audit rules expression not capable of ecore meta-model access")
  @constraintsMeta(def="context", ocl="attribute.eType")
  class DomainAttributeTarget extends Auditable {

    @GenModel(documentation="The attribute the value of which is used as context in audit rule defining this target")
    ref ecore.EAttribute[1] attribute;

    @GenModel(documentation="Indicates whether null value of the attribute is reported as audit failure or success")
    attr boolean nullAsError;
  }

  @GenModel(documentation="Target for rules applied on diagram notation model selectively, for specific visualized element")
  @constraintsMeta(def="context", ocl="if element.oclIsKindOf(NodeMapping) then 'notation::Node' else 'notation::Edge' endif")
  class DiagramElementTarget extends Auditable, Measurable {

    @GenModel(documentation="Targeted visualized element")
    ref MappingEntry[1] element;
  }

  @GenModel(documentation="Target for rules applied on diagram notation model elements")
  @constraintsMeta(def="context", ocl="element")
  class NotationElementTarget extends Auditable, Measurable {

    @GenModel(documentation="Targeted diagram notation model element")
    @constraints(ocl="element.eAllSuperTypes->including(element)->one(ePackage.name = 'notation' and name = 'View')", description="'notation::View' or its sub-class must be set to NotationElement target")
    ref EClass[1] element;
  }

  class MetricContainer {
    val MetricRule[+]#container metrics;
  }

  @constraints(ocl="not lowLimit.oclIsUndefined() and not highLimit.oclIsUndefined()  implies lowLimit < highLimit", description="Metric value 'lowLimit' must be smaller then 'highLimit'")
  class MetricRule extends RuleBase {

    @GenModel(documentation="Unique key identifying this metric an abbreviation for this metric")
    @constraints(ocl="not key.oclIsUndefined() implies container.metrics->one(i | i.key = self.key)", description="Metric rule with the same 'key' already exists")
    attr String[1] key;

    @GenModel(documentation="Expression that calculates the value of this metric which is of EDataType that encapsulates java.lang.Number subclasses or their primitives")
    @constraintsMeta(def="context", "ref"="target")
    @constraintsMeta(def="type", ocl="'ecore::EDoubleObject'")
    val ValueExpression[1] rule;

    @GenModel(documentation="The target representing the context this metric is evaluated in")
    val Measurable[1] target;

    @GenModel(documentation="The lowest acceptable value of the rule expression result")
    attr Double lowLimit;

    @GenModel(documentation="The highest acceptable value of the rule expression result")
    attr Double highLimit;

    @GenModel(documentation="The containing metric container of this metric rule")
    ref MetricContainer[1]#metrics container;
  }

  @GenModel(documentation="Target metric which can be evaluated by audit rule. The target context here is the metric rule resulting type classifier")
  @constraintsMeta(def="context", ocl="'ecore::EDoubleObject'")
  class AuditedMetricTarget extends Auditable {

    @GenModel(documentation="Metric which can be checked by audit")
    ref MetricRule[1] metric;
  }

  @GenModel(documentation="Target suitable for auditing")
  abstract interface Auditable {
  }

  @GenModel(documentation="Marker interface for anything that can be subject to metrics")
  abstract interface Measurable {
  }

  enum Severity {
    INFO = 0;
    WARNING = 1;
    ERROR = 2;
  }

  enum Language {
    ocl = 0;
    java = 1;
    regexp = 2;
    nregexp = 3;
    literal = 4;
  }

  class VisualEffectMapping {
    ref gmfgraph.Pin[1] diagramPin;
    attr String oclExpression;
    readonly ref MappingEntry[1]#visualEffects parentMapEntry;
  }

}

@namespace(uri="http://www.eclipse.org/gmf/2005/ToolDefinition", prefix="tooldef")
package tooldef {
  class ToolRegistry {

    @GenModel(documentation="Instead of placing	common actions somewhere in menu hierarchy and referencing them in (2..n) cases, keep them in this central registry and use ItemRef everywhere (i.e. in 1..n cases)")
    val MenuAction[*] sharedActions;
    val Menu[*] allMenus;
    val Palette palette;
  }

  abstract class AbstractTool {
    val Image smallIcon;
    val Image largeIcon;
    attr String title;
    attr String description;
  }

  abstract class ToolContainer extends AbstractTool {
    val AbstractTool[*] tools;
  }

  class PaletteSeparator extends AbstractTool {
  }

  class ToolGroup extends ToolContainer {
    attr boolean collapsible;
    attr boolean stack;
    ref AbstractTool active;
  }

  class Palette extends ToolContainer {
    ref AbstractTool default;
  }

  @GenModel(documentation="predefined, like zoom or marquee")
  class StandardTool extends AbstractTool {
    attr StandardToolKind toolKind;
  }

  enum StandardToolKind {
    SELECT = 0;
    SELECT_PAN = 1;
    MARQUEE = 2;
    ZOOM_PAN = 3;
    ZOOM_IN = 4;
    ZOOM_OUT = 5;
  }

  class CreationTool extends AbstractTool {
  }

  class GenericTool extends AbstractTool {
    attr String[1] toolClass;
  }

  abstract interface ItemBase {
  }

  abstract class Menu {
    val ItemBase[*] items;
  }

  class Separator extends ItemBase {
    attr String name;
  }

  class PredefinedItem extends ItemBase {
    attr String identifier;
  }

  class PredefinedMenu extends Menu, PredefinedItem {
  }

  abstract interface ContributionItem extends ItemBase {
    val Image icon;
    attr String title;
  }

  class MenuAction extends ContributionItem {
    attr ActionKind kind;
    attr String hotKey;
  }

  class ItemRef extends ItemBase {
    ref ItemBase[1] item;
  }

  class ContextMenu extends Menu {
    ref MenuAction default;
  }

  class PopupMenu extends Menu, ContributionItem {
    id attr String iD;
  }

  @GenModel(documentation="no default action and no id, just a collection of items")
  class MainMenu extends Menu {
    attr String title;
  }

  class Toolbar extends Menu {
  }

  enum ActionKind {
    CREATE = 0;
    PROPCHANGE = 1;
    MODIFY = 2;
    PROCESS = 3;
    CUSTOM = 99;
  }

  abstract interface Image {
  }

  @GenModel(documentation="Delegate to EMF.Edit providers")
  class DefaultImage extends Image {
  }

  @GenModel(documentation="Image bundled as part of distribution")
  class BundleImage extends Image {

    @GenModel(documentation="Relative path to image")
    attr String path;

    @GenModel(documentation="Empty value means image path is relative to generated bundle")
    attr String bundle;
  }

  abstract interface StyleSelector {
    op boolean isOk(EJavaObject style);
  }

  class GenericStyleSelector extends StyleSelector {
    attr AppearanceStyle[+] values;
  }

  enum AppearanceStyle {
    Font = 0;
    Fill = 1;
    Line = 2;
  }

}

@namespace(uri="http://www.eclipse.org/gmf/2006/GraphicalDefinition", prefix="gmfgraph")
package gmfgraph {
  class Canvas extends Identity {

    @GenModel(documentation="containment here doesn't restrict nodes/connection from using figure galeries defined elsewhere. No assumption should be made whether or not node/connection figure is defined in the galery beloning to this canvas")
    val FigureGallery[*] figures;
    val Node[*] nodes;
    val Connection[*] connections;
    val Compartment[*] compartments;
    val DiagramLabel[*] labels;
  }

  @GenModel(documentation="Kind of explicit figure library notion. Bundle of figures. Allows to specify plugin id (allows importing it later from gmfgen code) in addition to figures")
  class FigureGallery extends Identity {
    val RealFigure[*] figures;
    val FigureDescriptor[*] descriptors;

    @GenModel(documentation="Borders for reuse")
    val Border[*] borders;

    @GenModel(documentation="Layouts for reuse")
    val Layout[*] layouts;
    attr String implementationBundle;
  }

  @GenModel(documentation="Easy and readable way to reference element of the model from another one")
  abstract interface Identity {
    id attr String[1] name;
  }

  abstract class DiagramElement extends Identity {
    ref FigureDescriptor[1] figure;

    @GenModel(documentation="anything to further specify constraint or any other aspect of the element")
    val VisualFacet[*] facets;
  }

  abstract class AbstractNode extends DiagramElement {
  }

  class Node extends AbstractNode {
    attr Direction resizeConstraint = "NSEW";
    attr Direction affixedParentSide = "NONE";
    ref ChildAccess contentPane;
  }

  class Connection extends DiagramElement {
  }

  class Compartment extends DiagramElement {
    attr boolean collapsible;
    attr boolean needsTitle;
    ref ChildAccess accessor;
  }

  class DiagramLabel extends Node {
    attr boolean elementIcon = true;
    ref ChildAccess accessor;
    ref ChildAccess container;
    readonly volatile transient derived attr boolean external;
  }

  abstract interface VisualFacet {
  }

  @GenModel(documentation="provide means to attach arbitrary data to your diagram element definition. It's up to you (template author) to process it somehow.")
  class GeneralFacet extends VisualFacet {
    id attr String identifier;
    attr String data;
  }

  @GenModel(documentation="Makes sense for DiagramLabels of Links only (now). Constants from {@link org.eclipse.draw2d.ConnectionLocator} are: MIDDLE = Alignment.CENTER, TARGET = Alignment.END, SOURCE = Alignment.BEGINNING")
  class AlignmentFacet extends VisualFacet {
    attr Alignment alignment;
  }

  class GradientFacet extends VisualFacet {
    attr Direction direction;
  }

  class LabelOffsetFacet extends VisualFacet {
    attr int x;
    attr int y;
  }

  class DefaultSizeFacet extends VisualFacet {
    val Dimension defaultSize;
  }

  @GenModel(documentation="Anything you could combine visual representation from. Ordinary GEF figures, custom-defined or references to defined elsewhere. org.eclipse.draw2d.Figure")
  abstract interface Figure extends Layoutable {
    readonly volatile transient derived !resolve ref FigureDescriptor descriptor;
    val Color foregroundColor;
    val Color backgroundColor;
    val Dimension maximumSize;
    val Dimension minimumSize;
    val Dimension preferredSize;
    val Font font;
    val Insets insets;
    val Border border;
    val Point location;
    val Point size;
  }

  @GenModel(documentation="This is merely an implementation artifact to get only one base implementation of Figure attributes")
  abstract class AbstractFigure extends Figure {
  }

  @GenModel(documentation="The thing describes structure of a figure")
  class FigureDescriptor extends Identity {
    val Figure[1] actualFigure;
    val ChildAccess[*]#owner accessors;
  }

  class ChildAccess {
    readonly !resolve ref FigureDescriptor[1]#accessors owner;
    attr String accessor;

    @GenModel(documentation="This may also point to RealFigure from FigureAccessor#typedFigure")
    ref Figure[1] figure;
  }

  @GenModel(documentation="This is exact/specific/concrete figure, unlike proxy/reference-nature FigureRef")
  abstract class RealFigure extends AbstractFigure, PinOwner, CustomAttributeOwner {
    attr String name;
    val Figure[*] children;
  }

  @GenModel(documentation="Need this to facilitate reuse of figures while keeping (so nice looking) containment relationship in the Figure class")
  class FigureRef extends AbstractFigure {

    @GenModel(documentation="not just Figure because don't want to reference figure references.")
    ref RealFigure[1] figure;
  }

  abstract interface ConnectionFigure extends RealFigure {
  }

  abstract interface DecorationFigure extends RealFigure {
  }

  @GenModel(documentation="org.eclipse.draw2d.Shape")
  abstract class Shape extends RealFigure {
    attr boolean outline = true;
    attr boolean fill = true;
    attr int lineWidth = 1;
    attr LineKind lineKind;
    attr boolean xorFill;
    attr boolean xorOutline;

    @GenModel(documentation="Same as children, but resolves child FigureRefs, if any, to Figures")
    readonly volatile transient derived ref Figure[*] resolvedChildren;
  }

  @GenModel(documentation="org.eclipse.gmf.runtime.draw2d.ui.figures.WrappingLabel")
  class Label extends RealFigure {
    attr String text;
  }

  @GenModel(documentation="org.eclipse.draw2d.LabeledContainer")
  class LabeledContainer extends RealFigure {
  }

  @GenModel(documentation="org.eclipse.gmf.tooling.runtime.draw2d.labels.VerticalLabel")
  class VerticalLabel extends RealFigure {
    attr String text;
  }

  @GenModel(documentation="org.eclipse.draw2d.RectangleFigure")
  class Rectangle extends Shape {
  }

  @GenModel(documentation="org.eclipse.draw2d.RectangleFigure #opaque=false, #outline=false, #fill=false")
  class InvisibleRectangle extends RealFigure {
  }

  @GenModel(documentation="org.eclipse.draw2d.RoundedRectangle")
  class RoundedRectangle extends Shape {
    attr int cornerWidth = 8;
    attr int cornerHeight = 8;
  }

  @GenModel(documentation="org.eclipse.draw2d.Ellipse")
  class Ellipse extends Shape {
  }

  @GenModel(documentation="org.eclipse.draw2d.Polyline")
  class Polyline extends Shape {
    val Point[*] template;
  }

  @GenModel(documentation="org.eclipse.draw2d.Polygon")
  class Polygon extends Polyline {
  }

  @GenModel(documentation="Marker interface to denote polygons with ability to autoscale to fit all available bounds. Separate class is needed instead of property in the Polygon class because of generalization PolygonDecoration extends Polygon")
  class ScalablePolygon extends Polygon {
  }

  @GenModel(documentation="org.eclipse.draw2d.PolylineConnection")
  class PolylineConnection extends Polyline, ConnectionFigure {
    ref DecorationFigure sourceDecoration;
    ref DecorationFigure targetDecoration;
  }

  @GenModel(documentation="org.eclipse.draw2d.PolylineDecoration")
  class PolylineDecoration extends Polyline, DecorationFigure {
  }

  @GenModel(documentation="org.eclipse.draw2d.PolygonDecoration")
  class PolygonDecoration extends Polygon, DecorationFigure {
  }

  abstract interface CustomAttributeOwner {
    val CustomAttribute[*] attributes;
  }

  abstract interface CustomClass extends CustomAttributeOwner {
    attr String qualifiedClassName;
  }

  class CustomAttribute {
    attr String[1] name;
    attr String[1] value = "null";
    attr boolean[1] directAccess = false;
    attr boolean[1] multiStatementValue = false;
  }

  class FigureAccessor {
    attr String[1] accessor;
    val RealFigure[1] typedFigure;
  }

  @GenModel(documentation="Any figure class provided by some bundle")
  class CustomFigure extends RealFigure, CustomClass {

    @GenModel(documentation="Childrent enumerated with this feature are mere 'access points' to actual structure of the CustomFigure. They are not created, unlike those contained in regular Figure#children")
    val FigureAccessor[*] customChildren;
  }

  @GenModel(documentation="Same as CustomFigure, but for Decorations")
  class CustomDecoration extends CustomFigure, DecorationFigure {
  }

  @GenModel(documentation="Same as CustomFigure, but for Connections")
  class CustomConnection extends CustomFigure, ConnectionFigure {
  }

  abstract interface Color {
  }

  class RGBColor extends Color {
    attr int[1] red;
    attr int[1] green;
    attr int[1] blue;
  }

  class ConstantColor extends Color {
    attr ColorConstants[1] value;
  }

  enum ColorConstants {
    white = 0;
    black = 1;
    lightGray = 2;
    gray = 3;
    darkGray = 4;
    red = 5;
    orange = 6;
    yellow = 7;
    green = 8;
    lightGreen = 9;
    darkGreen = 10;
    cyan = 11;
    lightBlue = 12;
    blue = 13;
    darkBlue = 14;
  }

  abstract interface Font {
  }

  class BasicFont extends Font {
    attr String faceName;
    attr int height = 9;
    attr FontStyle style = "NORMAL";
  }

  enum FontStyle {
    NORMAL = 0;
    BOLD = 1;
    ITALIC = 2;
  }

  class Point {
    attr int x;
    attr int y;
  }

  class Dimension {
    attr int dx;
    attr int dy;
  }

  class Insets {
    attr int top;
    attr int left;
    attr int bottom;
    attr int right;
  }

  abstract interface Border {
  }

  @GenModel(documentation="Border reuse mechanism")
  class BorderRef extends Border {

    @GenModel(documentation="constraint: actual should not be another BorderRef")
    ref Border[1] actual;
  }

  class LineBorder extends Border {
    val Color color;
    attr int width = 1;
  }

  class MarginBorder extends Border {
    val Insets insets;
  }

  class CompoundBorder extends Border {
    val Border outer;
    val Border inner;
  }

  class CustomBorder extends Border, CustomClass {
  }

  @GenModel(documentation="Geographical bit constants from org.eclipse.draw2d.PositionConstants")
  enum Direction {
    NONE = 0;
    NORTH = 1;
    SOUTH = 4;
    WEST = 8;
    EAST = 16;
    NORTH_EAST = 17;
    NORTH_WEST = 9;
    SOUTH_EAST = 20;
    SOUTH_WEST = 12;
    NORTH_SOUTH = 5;
    EAST_WEST = 24;
    NSEW = 29;
  }

  @GenModel(documentation="org.eclipse.draw2d.Graphics.LINE_* (== org.eclipse.swt.SWT.LINE_*. Values are same as SWT constants")
  enum LineKind {
    LINE_SOLID = 1;
    LINE_DASH = 2;
    LINE_DOT = 3;
    LINE_DASHDOT = 4;
    LINE_DASHDOTDOT = 5;
    LINE_CUSTOM = 6;
  }

  abstract interface LayoutData {
    ref Layoutable[1]#layoutData owner;
  }

  class CustomLayoutData extends LayoutData, CustomClass {
  }

  class GridLayoutData extends LayoutData {
    attr boolean[1] grabExcessHorizontalSpace = false;
    attr boolean[1] grabExcessVerticalSpace = false;
    attr Alignment[1] verticalAlignment = "CENTER";
    attr Alignment[1] horizontalAlignment = "CENTER";
    attr int[1] verticalSpan = 1;
    attr int[1] horizontalSpan = 1;
    attr int[1] horizontalIndent;
    val Dimension sizeHint;
  }

  class BorderLayoutData extends LayoutData {
    attr Alignment[1] alignment = "CENTER";
    attr boolean vertical = false;
  }

  enum Alignment {
    BEGINNING = 0;
    CENTER = 1;
    END = 2;
    FILL = 3;
  }

  abstract interface Layoutable {
    val LayoutData#owner layoutData;
    val Layout layout;
  }

  abstract interface Layout {
  }

  @GenModel(documentation="Layout reuse mechanism")
  class LayoutRef extends Layout {

    @GenModel(documentation="constraint: actual should not be another LayoutRef")
    ref Layout[1] actual;
  }

  class CustomLayout extends Layout, CustomClass {
  }

  class GridLayout extends Layout {
    attr int[1] numColumns = 1;
    attr boolean[1] equalWidth = true;
    val Dimension margins;
    val Dimension spacing;
  }

  class BorderLayout extends Layout {
    val Dimension spacing;
  }

  class FlowLayout extends Layout {
    attr boolean vertical = false;
    attr boolean matchMinorSize = false;
    attr boolean forceSingleLine = false;
    attr Alignment majorAlignment = "BEGINNING";
    attr Alignment minorAlignment = "BEGINNING";
    attr int majorSpacing = 5;
    attr int minorSpacing = 5;
  }

  class XYLayout extends Layout {
  }

  class XYLayoutData extends LayoutData {
    val Point[1] topLeft;
    val Dimension[1] size;
  }

  class StackLayout extends Layout {
  }

  class CenterLayout extends Layout {
  }

  class SVGFigure extends RealFigure {
    attr String documentURI;
    val SVGProperty[*] properties;
    val Rectangle2D areaOfInterest;
    attr boolean noCanvasWidth;
    attr boolean noCanvasHeight;
  }

  class SVGProperty {
    attr String query;
    attr String attribute;
    attr SVGPropertyType type;
    attr String getter;
    attr String setter;
    attr boolean callSuper;
  }

  enum SVGPropertyType {
    STRING = 0;
    COLOR = 1;
    FLOAT = 2;
  }

  class Rectangle2D {
    attr float x;
    attr float y;
    attr float width;
    attr float height;
  }

  abstract interface Pin extends Identity {
    op String getOperationName();
    op String getOperationType();
  }

  class CustomPin extends Pin {
    attr String customOperationName;
    attr String customOperationType;
  }

  class ColorPin extends Pin {
    attr boolean backgroundNotForeground;
  }

  class VisiblePin extends Pin {
  }

  abstract interface PinOwner {
    val Pin[*] pins;
  }

}

